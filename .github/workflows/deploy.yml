name: Deploy to VMs

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=long
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    strategy:
      matrix:
        vm: [
          # Add your VM configurations here
          # { host: 'vm1.example.com', username: 'ubuntu' },
          # { host: 'vm2.example.com', username: 'ubuntu' }
        ]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan ${{ matrix.vm.host }} >> ~/.ssh/known_hosts

      - name: Deploy to VM
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          VM_HOST: ${{ matrix.vm.host }}
          VM_USER: ${{ matrix.vm.username }}
        run: |
          # Create temporary docker-compose.prod.yml with the correct image
          cat > docker-compose.vm.yml << EOL
          version: '3.8'
          services:
            app:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
              container_name: koppen-app
              restart: unless-stopped
              ports:
                - "8000:8000"
              environment:
                - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@db:5432/koppen
              command: ["uvicorn", "koppen.main:app", "--host", "0.0.0.0", "--port", "8000"]
              depends_on:
                - db

            db:
              image: postgres:16-alpine
              container_name: koppen-db
              restart: unless-stopped
              volumes:
                - postgres_data:/var/lib/postgresql/data
              environment:
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
                - POSTGRES_DB=koppen

          volumes:
            postgres_data:
          EOL

          # Copy the compose file to the VM
          scp docker-compose.vm.yml $VM_USER@$VM_HOST:~/docker-compose.yml

          # Deploy on the VM
          ssh $VM_USER@$VM_HOST << 'ENDSSH'
            # Create .env file with the database password
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" > .env

            # Pull the latest image and restart the services
            docker compose pull
            docker compose up -d
          ENDSSH
